# External vs Internal Events Pattern

This document describes a fundamental pattern for event sourcing: distinguishing between external events that occur outside the system and internal events generated by the system in response.

## Core Concepts

### External Events
External events represent things that happen in the real world, outside the control of your system:
- User interactions (clicks, form submissions)
- Time passing (new day, scheduled time reached)
- External system notifications (webhooks, API calls)
- Human decisions (votes, approvals, manual overrides)

**Key characteristic**: External events have NO `causationId` because nothing within the system caused them.

### Internal Events
Internal events are generated by the system itself in response to other events:
- Automated processes triggered by external events
- System reactions to state changes
- Cascading updates
- Calculated changes

**Key characteristic**: Internal events ALWAYS have a `causationId` pointing to the event that triggered them.

## The Causation Chain

This pattern creates clear causation chains:

```
External Event (no parent)
    └─→ Internal Event 1 (parent: external)
            └─→ Internal Event 2 (parent: internal 1)
                    └─→ Internal Event 3 (parent: internal 2)
```

## Examples

### Example 1: Motion and Rule Update

```javascript
// EXTERNAL: Motion passes (human decision)
await eventQueue.store({
  cmd: 'motionPassed',
  data: {
    motionId: 'MOTION-001',
    ruleId: 'RULE-PARKING',
    newContent: 'Updated parking rules',
    votes: { for: 7, against: 2 }
  },
  // No causationId - this is external!
  metadata: {
    source: 'city-council-meeting',
    meetingId: 'MEETING-2024-01'
  }
}, model, callbacks);

// INTERNAL: System updates the rule (automated response)
await eventQueue.store({
  cmd: 'updateRule',
  data: {
    ruleId: 'RULE-PARKING',
    content: 'Updated parking rules'
  },
  causationId: motionEventId,  // CAUSED BY the motion
  correlationId: motionCorrelationId,
  metadata: {
    ruleCorrelationId: 'RULE-PARKING-history'
  }
}, model, callbacks);
```

### Example 2: Scheduled Events

```javascript
// EXTERNAL: New day starts (time is external)
const newDayEvent = await eventQueue.store({
  cmd: 'newDayStarted',
  data: {
    date: '2024-01-16',
    dayOfWeek: 'Tuesday'
  },
  // No causationId - time is external to the system
  metadata: {
    source: 'cron-scheduler',
    timezone: 'UTC'
  }
}, model, callbacks);

// INTERNAL: Reset user daily limits (system response)
for (const user of users) {
  await eventQueue.store({
    cmd: 'resetUserDaily',
    data: { userId: user.id },
    causationId: newDayEvent.id,  // CAUSED BY new day
    correlationId: newDayCorrelationId,
    metadata: {
      userCorrelationId: `USER-${user.id}-daily`
    }
  }, model, callbacks);
}

// INTERNAL: End expired actions (system response)
for (const action of expiredActions) {
  await eventQueue.store({
    cmd: 'endExpiredAction',
    data: { actionId: action.id, reason: 'expired' },
    causationId: newDayEvent.id,  // CAUSED BY new day
    correlationId: action.originalCorrelationId,  // Primary: action lifecycle
    metadata: {
      dailyRunCorrelationId: newDayCorrelationId  // Secondary: daily batch
    }
  }, model, callbacks);
}
```

## Correlation Patterns

### Primary Correlation
The `correlationId` should represent the strongest business relationship:
- For motion-triggered updates: Use the motion's correlation
- For daily resets: Use the new day's correlation
- For expiring actions: Use the original action's correlation (stronger relationship than daily run)

### Secondary Correlations
Store additional relationships in metadata:
```javascript
metadata: {
  // Multiple correlation contexts
  userCorrelationId: 'USER-123-history',
  ruleCorrelationId: 'RULE-001-history',
  dailyBatchCorrelationId: '2024-01-16-daily',
  
  // Additional context
  source: 'web-ui',
  reason: 'scheduled',
  previousVersion: 1
}
```

## Common External Event Types

### User Interactions
```javascript
// User submits form
{ cmd: 'userSubmittedForm', data: {...} }  // No causationId

// User clicks button
{ cmd: 'userClickedApprove', data: {...} }  // No causationId

// User logs in
{ cmd: 'userLoggedIn', data: {...} }  // No causationId
```

### Time-Based Events
```javascript
// Scheduled time reached
{ cmd: 'scheduledTimeReached', data: {...} }  // No causationId

// Period ended
{ cmd: 'billingPeriodEnded', data: {...} }  // No causationId

// Timeout occurred
{ cmd: 'sessionTimedOut', data: {...} }  // No causationId
```

### External System Events
```javascript
// Webhook received
{ cmd: 'paymentWebhookReceived', data: {...} }  // No causationId

// Email bounced
{ cmd: 'emailBounced', data: {...} }  // No causationId

// API call received
{ cmd: 'apiRequestReceived', data: {...} }  // No causationId
```

## Implementation Guidelines

### 1. Identifying External Events
Ask: "Did something inside my system trigger this?"
- If NO → External event (no causationId)
- If YES → Internal event (requires causationId)

### 2. Designing Event Handlers
```javascript
methods(queries) {
  return {
    // External event handler
    userClickedButton(data, metadata) {
      // Process the external trigger
      // Often queues internal events for further processing
      return { acknowledged: true };
    },
    
    // Internal event handler
    processButtonAction(data, metadata) {
      // Always has metadata.causationId
      console.log(`Processing action caused by event ${metadata.causationId}`);
      // Perform system updates
      return { processed: true };
    }
  };
}
```

### 3. Event Naming Conventions
- External events: Past tense, subject-first
  - `userSubmitted`, `motionPassed`, `dayStarted`
- Internal events: Action-focused
  - `updateRule`, `resetCounter`, `calculateTotal`

### 4. Metadata Best Practices
For external events, include:
- `source`: Where the event originated
- `timestamp`: When it occurred externally
- `externalId`: ID from external system

For internal events, include:
- Secondary correlations
- Reason for generation
- Previous state references

## Benefits

### 1. Clear Audit Trail
Every internal event can be traced back to its external trigger:
```
Q: Why was this rule updated?
A: Event #45 (updateRule) was caused by Event #44 (motionPassed)
```

### 2. Easier Debugging
- External events = entry points to trace through
- Internal events = follow causation chain

### 3. Replay Safety
- External events can be replayed to regenerate all internal events
- Causation chains ensure correct ordering

### 4. Integration Points
- External events mark integration boundaries
- Easy to identify where external systems connect

## Advanced Patterns

### Batch Processing
When multiple internal events are triggered by one external event:
```javascript
// External: Batch job started
const batchEvent = await eventQueue.store({
  cmd: 'batchJobStarted',
  data: { jobType: 'daily-cleanup' }
}, model, callbacks);

// Internal: Multiple operations
for (const item of itemsToProcess) {
  await eventQueue.store({
    cmd: 'processItem',
    data: { itemId: item.id },
    causationId: batchEvent.id,
    correlationId: batchEvent.correlationId,
    metadata: {
      batchPosition: item.position,
      batchTotal: itemsToProcess.length
    }
  }, model, callbacks);
}
```

### Event Enrichment
External events often trigger enrichment:
```javascript
// External: Raw webhook
const webhookEvent = await eventQueue.store({
  cmd: 'webhookReceived',
  data: { payload: rawPayload }
}, model, callbacks);

// Internal: Enriched processing
await eventQueue.store({
  cmd: 'processPayment',
  data: {
    ...parsedPayload,
    userId: lookedUpUserId,
    accountId: lookedUpAccountId
  },
  causationId: webhookEvent.id
}, model, callbacks);
```

## Summary

The external/internal event distinction provides:
1. **Clarity**: Clear boundaries between system and world
2. **Traceability**: Every change can be traced to its origin
3. **Simplicity**: Consistent pattern for all events
4. **Flexibility**: Multiple correlation contexts via metadata

By following this pattern, your event-sourced system will have a clear, auditable, and maintainable event structure.